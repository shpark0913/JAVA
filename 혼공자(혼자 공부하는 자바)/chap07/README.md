- **상속**
  
  
  - 부모 클래스의 멤버를 자식 클래스에게 물려주는 것
  
  - 프로그램에서는
    
    - 부모 클래스 → `상위 클래스`라 부르고
    - 자식 클래스 → `하위 클래스` 또는 `파생 클래스`라고 부름
  
  - 이미 잘 개발된 클래스를 재사용해서 새로운 클래스를 만듦 → **중복되는 코드를 줄여준다.**
  
  - 부모 클래스의 수정으로 모든 자식 클래스들도 수정되는 효과를 가져오기 때문에 유지 보수 시간 최소화할 수 있음

---

- **클래스 상속**
  
  - 프로그램에서는 자식이 부모를 선택
    
    - 자식 클래스를 선언할 때 어떤 부모 클래스를 상속받을 것인지 결정하고, 선택된 부모 클래스는 extends 뒤에 기술함
    
    ```java
    class 자식클래스 extends 부모클래스 {
        //필드
        //생성자
        //메소드
    }
    ```
  
  - 상속의 특징
    
    1. 여러 개의 부모 클래스를 상속할 수 없다.
       - extends 뒤에는 단 하나의 부모 클래스만 와야 함
    2. 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외됨
       1. 부모 클래스와 자식 클래스가 다른 패키지에 존재한다면 default 접근 제한을 갖는 필드와 메소드도 상속 대상에서 제외됨

---

- **부모 생성자 호출**
  
  - 자식 객체를 생성하면, 부모 객체가 먼저 생성되고 그다음에 자식 객체가 생성됨
  
  - `DmbCellPhone dmbCellPhone = new DmbCellPhone();`
    
    - DmbCellPhone 객체만 생성하는 것처럼 보이지만,
      
      사실은 내부적으로 부모인 CellPhone 객체가 먼저 생성되고
      
      자식인 DmbCellPhone 객체가 생성됨
  
  - 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출됨
    
    - WHY?
      
      → 모든 객체는 클래스의 생성자를 호출해야만 생성되며, 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출됨
    
    - ex) DmbCellPhone의 생성자가 명시적으로 선언되지 않는다면, 컴파일러는 다음과 같이 기본 생성자를 생성함
      
      ```java
      public DmbCellPhone() {
          super();
      }
      ```
      
      - `super();`는 부모의 기본 생성자를 호출함
    
    - 직접 자식 생성자를 선언하고 명시적으로 부모 생성자를 호출하고 싶다면?
      
      ```java
      자식클래스( 매개변수선언, ... ) {
          super( 매개값, ... );
          ...
      }
      ```
      
      - `super( 매개값, ... )`는 매개값의 타입과 일치하는 부모 생성자를 호출
        - 매개값과 일치하는 부모 생성자가 없을 경우 컴파일 에러 발생
      - `super( 매개값, ... )`가 생략되면 컴파일러에 의해 `super()`가 자동적으로 추가되기 때문에 부모의 기본 생성자가 존재해야 함
        - 부모 클래스에 기본 생성자가 없고 매개 변수가 있는 생성자만 있다면 자식 생성자에서 반드시 부모 생성자 호출을 위해 `super( 매개값, ... )`를 명시적으로 호출해야 함!!!
          - `super( 매개값, ... )`는 반드시 자식 생성자 첫 줄에 위치해야 하며, 그렇지 않으면 컴파일 에러가 발생함!!!

---

- **메소드 재정의**
  
  - 부모 클래스의 어떤 메소드는 자식 클래스가 사용하기에 적합하지 않을 수도 있다.
    
    - 이 경우 상속된 일부 메소드는 자식 클래스에서 다시 수정해서 사용해야 함.
    - 이런 경우를 위해 **메소드 재정의**(오버라이딩) 기능을 제공함.
  
  - 메소드 재정의 방법
    
    - 메소드 재정의
      - 자식 클래스에서 부모 클래스의 메소드를 다시 정의하는 것. 재정의할 때는 다음과 같은 규칙에 주의해서 작성하자
        1. 부모의 메소드와 동일한 시그니처 (리턴 타입, 메소드 이름, 매개 변수 목록) 를 가져야 함
        2. 접근 제한을 더 강하게 재정의할 수 없음
           - 부모 메소드가 public 접근 제한을 가지고 있을 경우 재정의하는 자식 메소드는 default나 private 접근 제한으로 수정할 수 없다는 뜻
           - 반대는 가능. 부모 메소드가 default 접근 제한을 가지면 재정의하는 자식 메소드는 default 또는 public 접근 제한을 가질 수 있음
        3. 새로운 예외 (Exception) 를 throws 할 수 없음
    - 메소드가 재정의되었다면 부모 객체의 메소드는 숨겨지기 때문에, 자식 객체에서 메소드를 호출하면 재정의된 자식 메소드가 호출됨
  
  - 부모 메소드 호출
    
    - 자식 클래스에서 부모 클래스의 메소드를 재정의하게 되면, 부모 클래스의 메소드는 숨겨지고 재정의된 자식 메소드만 사용됨
    
    - 그러나 자식 클래스 내부에서 재정의된 부모 클래스의 메소드를 호출해야 하는 상황이 발생한다면 **명시적으로 super 키워드를 붙여서 부모 메소드를 호출** 할 수 있다.
      
      `super.부모메소드();`

---

- **final 클래스와 final 메소드**
  - final 키워드
    - 클래스, 필드, 메소드를 선언할 때 사용 가능
    - 해당 선언이 최종 상태이고 결코 수정될 수 없음
    - 클래스, 필드, 메소드 선언에 사용될 경우 해석이 조금씩 달라지는데, **필드 선언 시** final이 지정되면 초기값 설정 후 더 이상 값을 변경할 수 없음
    - **클래스, 메소드 선언 시 final 키워드가 지정되면 상속과 관련이 있다는 의미**
  - 상속할 수 없는 final 클래스
    - 클래스를 선언할 때 final 키워드를 class 앞에 붙이면 이 클래스는 최종적인 클래스이므로 상속할 수 없는 클래스가 됨
    - final 클래스는 부모 클래스가 될 수 없어 자식 클래스를 만들 수 없다
    - `public final class 클래스 { ... }`
    - 예시
      - 자바 표준 API에서 제공하는 String 클래스
        - `public final class String { ... }`
        - 따라서 다음과 같이 자식 클래스를 만들 수 없음
          - `public class NewString ~~extends String~~ { ... }`
