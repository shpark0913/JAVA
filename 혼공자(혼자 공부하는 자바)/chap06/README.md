## 🔶객체 지향 프로그래밍 (OOP : Object-Oriented Programming)

- **객체**
  - 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있으면서 식별 가능한 것.
  - 속성(필드)과 동작(메소드)으로 구성되어 있다.
  - 객체의 예시
    - 사람
      - 필드 : 이름, 나이 등..
      - 메소드 : 웃다, 걷다 등..
    - 자동차
      - 필드 : 색깔, 모델 등..
      - 메소드 : 달린다, 멈춘다 등

---

- **객체 모델링**
  - 현실 세계의 객체를 소프트웨어 객체로 설계하는 것
  - 현실 세계 객체의 속성과 동작을 소프트웨어 객체의 필드와 메소드로 정의하는 과정

---

- **객체의 상호작용**
  - 객체들은 각각 독립적으로 존재하고, 다른 객체와 서로 상호작용하면서 동작
    - **메소드** : 객체들 사이의 상호작용 수단
    - **메소드 호출** : 객체가 다른 객체의 기능을 이용하는 것
      - ex) 사람이 전자계산기를 사용한다면?
        - `**리턴값 = 전자계산기객체.메소드(매개값1, 매개값2, ...)**`
    - 객체의 상호작용은 객체 간의 메소드 호출을 의미하며 **매개값과 리턴값을 통해서 데이터를 주고받는다.**

---

- **객체 간의 관계**
  - 객체는 개별적으로 사용 가능. BUT 대부분 다른 객체와 관계를 맺고 있다.
  - 관계의 종류 : 집합 관계, 사용 관계, 상속 관계
    - ex) 집합 관계 : 부품과 자동차
    - ex) 사용 관계 : 사람과 자동차
    - ex) 상속 관계 : 기계와 자동차
  - 객체 지향 프로그래밍은 만들고자 하는 완성품인 객체를 모델링하고, 집합 관계에 있는 부품 객체와 사용 관계에 있는 객체를 하나씩 설계한 후 조립하는 방식으로 프로그램을 개발하는 기법

---

- **객체와 클래스**
  - 메모리에서 사용하고 싶은 객체가 있다면 우선 설계도로 해당 객체를 만드는 작업이 필요
  - 설계도가 바로 **클래스(class)**
    - 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있음
    - 클래스로부터 만들어진 객체를 해당 클래스의 **인스턴스**라고 함
  - 객체를 생성하는 순서
    - 개발자 —(설계)→ 클래스 —(인스턴스화)→ 인스턴스(객체)
  - 객체 지향 프로그래밍 개발의 3단계
    1. 클래스 설계
    2. 설계된 클래스를 가지고 사용할 객체 생성
    3. 생성된 객체를 이용

---

- **클래스 선언**
  
  - 사용하고자 하는 객체를 구상했다면, 그 객체의 대표 이름을 하나 결정하고 이것을 클래스 이름으로 정한다.
  
  - 자바의 클래스 이름은 다른 클래스와 식별할 목적이므로 식별자 작성 규칙에 따르자!
    
    - 식별자 작성 규칙
      - 하나 이상의 문자로 이루어져야 한다.
      - 첫 글자에는 숫자가 올 수 없다.
      - $, _ 외의 특수 문자는 사용할 수 없다.
      - 자바 키워드는 사용할 수 없다.
  
  - 클래스 이름을 정했다면 “클래스 이름.java”로 소스 파일을 생성.
    
    - 소스 파일 이름도 대소문자 구분하므로 반드시 클래스 이름과 대소문자가 같도록 하기
    
    ```java
    public class 클래스이름 {
    
    }
    ```
    
    - public class 키워드는 클래스를 선언할 때 사용, 반드시 소문자로!
    - { : 클래스 선언의 시작
    - } : 클래스 선언의 끝
  
  - 일반적으로 소스 파일당 하나의 클래스 선언. BUT 2개 이상의 클래스 선언도 가능
    
    - 소스 파일은 클래스 선언을 담고 있는 저장 단위일 뿐, 클래스 자체가 아님
  
  - 참고) `public 접근 제한자`
    
    - public 접근 제한자는 파일 이름과 동일한 이름의 클래스 선언에만 붙일 수 있다.
    - 파일 이름과 일치하지 않는 클래스 선언에 붙이면 컴파일 에러가 발생
    - 따라서 가급적 소스 파일 하나당 동일한 이름의 클래스 하나만 선언하자!

---

- **객체 생성과 클래스 변수**
  
  - 클래스로부터 객체를 생성하려면?
    
    - new 연산자 사용하기
      
      - `new 클래스();`
      
      - new 연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다.
      
      - new 연산자로 생성된 객체는 메모리 힙 영역에 생성된다.
        
        - new 연산자는 힙 영역에 객체 생성 후 객체의 번지를 리턴한다. (객체의 위치를 모르면 사용할 수 없기 때문에!)
        
        - **이 주소를 참조 타입인 클래스 변수에 저장해두면 변수를 통해 객체를 사용할 수 있다.**
          
          ```java
          방법 1)
          클래스 변수;
          변수 = new 클래스();
          
          방법 2)
          클래스 변수 = new 클래스();
          ```

---

- **클래스의 용도(2가지)**
  - 라이브러리용 & 실행용
  - 라이브러리 클래스 : 다른 클래스에서 이용할 목적으로 설계됨
  - 실행 클래스 : 프로그램의 실행 진입점인 main() 메소드를 제공하는 역할을 함.
    - 프로그램 전체에서 사용되는 클래스가 100개라면 99개는 라이브러리 클래스, 1개가 실행 클래스
  - 대부분의 객체 지향 프로그램은 **라이브러리(부품 객체 및 완성 객체)**와 **실행 클래스**가 분리되어 있음

---

- **클래스의 구성 멤버**
  - 클래스에는 객체가 가져야 할 구성 멤버가 선언됨.
    - 구성 멤버
      1. 필드 (Field)
         - 객체의 데이터가 저장되는 곳
         - 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳
         - 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재
           - 비교) 변수는 생성자와 메소드 내에서만 사용, 생성자와 메소드가 실행 종료되면 자동 소멸
      2. 생성자 (Constructor)
         - 객체 생성 시 초기화 역할 담당
         - new 연산자로 호출되는 특별한 { } 블록
      3. 메소드 (Method)
         - 객체의 동작에 해당하는 실행 블록(중괄호 블록)
         - 메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행됨

---

## 필드

- **필드**
  
  - 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장하는 곳
  - ex) 자동차 객체
    - 고유 데이터 : 제작회사, 모델, 색깔, 최고 속도
    - 상태 데이터 : 현재 속도, 엔진 회전 수
    - 부품 : 차체, 엔진, 타이어
    - **위 정보들은 자동차 클래스를 설계할 때 필드로 선언되어야 한다.**

- **필드 선언**
  
  - 클래스 중괄호 {} 블록 어디서든 존재할 수 있다.
  
  - **BUT** 생성자와 메소드 중괄호 {} 브록 내부에는 선언될 수 없다
    
    - 생성자와 메소드 중괄호 블록 내부에 선언된 것은 모두 로컬 변수가 되기 때문!
  
  - 필드 선언은 변수의 선언 형태와 비슷
    
    - 일부 사람들은 클래스 멤버 변수라고 부름. 하지만 될 수 있으면 필드라는 용어 그대로 사용하자!
  
  - `타입 필드 [ = 초기값 ]`
    
    - 선언 형태는 변수와 비슷하지만, 필드를 변수라고 부르지는 않는다!
    - 타입은 필드에 저장할 데이터의 종류를 결정
      - 기본 타입(byte, short, int, long, float, double, boolean), 참조 타입(배열, 열거, 인터페이스) 이 모두 올 수 있음
      - 필드의 초기값은 필드 선언 시 주어질 수도 있고, 생략될 수도 있음
    - 올바르게 필드를 선언한 예시
    
    ```java
    String company = "현대자동차";
    String model = "그랜저";
    int maxSpeed = 300;
    int productionYear;
    int currentSpeed;
    boolean engineStart;
    ```
    
    - 초기값이 지정되지 않은 필드는 객체 생성 시 자동으로 기본 초기값으로 설정됨
      - 기본 타입
        - 정수 타입
          - byte : 0
          - char : \u0000 (빈 공백)
          - short : 0
          - int : 0
          - long : 0L
        - 실수 타입
          - float : 0.0F
          - double : 0.0
        - 논리 타입
          - boolean : false
      - 참조 타입
        - 배열 : null
        - 클래스(String 포함) : null
        - 인터페이스 : null

- **필드 사용**
  
  - 필드값을 읽고 변경하는 작업
  - 클래스 내부의 생성자나 메소드에서 사용할 경우
    - 단순히 필드 이름으로 읽고 변경
  - 클래스 외부에서 사용할 경우
    - 클래스로부터 객체를 생성한 뒤 필드를 사용해야 한다.
      - 필드가 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않기 때문이다!!

- **정리**
  
  - 필드 선언 : 클래스 중괄호 {} 블록 어디서든 선언하나, 생성자와 메소드 내부에서는 선언할 수 없다.
  - 필드 사용 : 클래스 내부의 생성자와 메소드에서 바로 사용이 가능하나, 클래스 외부에서 사용할 경우에는 반드시 객체를 생성하고 참조 변수를 통해 사용해야 한다.

---

## 생성자

- **개요**
  
  - 생성자란?
    - new 연산자로 호출되는 중괄호 {} 블록
    - 객체 생성 시 초기화를 담당
    - 모든 클래스에 **반드시 하나 이상** 존재
      - **클래스 내부에 선언을 생략하면 기본 생성자가 자동으로 추가됨.**

- **생성자(Constructor)**
  
  - new 연산자로 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당
    - 객체 초기화
      - 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 하는 것
  - 생성자를 실행하지 않고는 클래스로부터 객체를 만들 수 없다!
    - 생성자가 성공적으로 실행되지 않고 예외(에러)가 발생했다면 객체는 생성되지 않는다.
  - new 연산자에 의해 생성자가 성공적으로 실행되면
    1. 힙(heap) 영역에 객체가 생성됨.
    2. 객체의 번지가 리턴됨.
    3. 리턴된 객체의 번지는 클래스 변수에 저장됨.

- **기본 생성자**
  
  - 모든 클래스에는 생성자가 반드시 하나 이상 존재
    
    - 클래스 내부에 생성자 선언을 생략했다면?
      
      → 컴파일러는 중괄호 {} 블록 내용이 비어 있는 **기본 생성자**를 바이트 코드에 자동 추가
      
      `[public] 클래스() {}`
      
      - 클래스가 public class로 선언되면 기본 생성자에도 public이 붙음
      - 클래스가 public 없이 class로만 선언되면 기본 생성자에도 public이 붙지 않음
      
      ex)
      
      ```java
      소스 파일(Car.java)
      public class Car {
      }
      
      -> 컴파일 ->
      
      바이트 코드 파일(Car.class)
      public class Car {
          public Car() { } //자동 추가
      }
      ```
      
      - 따라서 클래스에 생성자를 선언하지 않아도 new 연산자 뒤에 기본 생성자를 호출해서 객체 생성 가능
        
        ex) `Car myCar = new Car();`
  
  - 명시적으로 선언한 생성자가 1개라도 있으면 컴파일러는 기본 생성자를 추가하지 않는다.
    
    - 명시적으로 생성자를 선언하는 이유는?
      
      → 객체를 다양한 값으로 초기화하기 위해서!
      
      그렇다면 이제 생성자를 명시적으로 선언하는 방법을 공부해보자!!

- **생성자 선언**
  
  - 기본 생성자 대신 명시적으로 선언하려면 다음과 같이 하자!
  
  ```java
  클래스( 매개변수 선언, ...) {
      //객체의 초기화 코드
  }
  ```
  
  - 생성자는 메소드와 비슷한 모양을 가지고 있으나, 리턴 타입이 없고 클래스 이름과 동일
  
  - 생성자 블록 내부에는 객체 초기화 코드가 작성됨
    
    - 일반적으로 필드에 초기값을 저장하거나
    - 메소드를 호출하여 객체 사용 전에 필요한 준비를 함
  
  - 매개변수 선언은 생략할 수도 있고 여러 개를 선언할 수도 있다.
    
    - 매개변수의 역할은?
      
      - new 연산자로 생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달하는 역할을 함.
      
      ex) `Car myCar = new Car("그랜저", "검정", 300);`
      
      - 2개의 매개값은 String 타입, 마지막 매개값은 int 타입
      - 세 매개값을 생성자가 받기 위해서는 다음과 같이 매개 변수를 선언해야 한다.
      
      ```java
      public class Car {
          //생성자
          Car(String model, String color, int maxSpeed) { ... }
      }
      ```
    
    - 매개 변수의 이름이 너무 짧으면 코드의 가독성이 좋지 않기 때문에, 가능하면 초기화시킬 필드 이름과 비슷하거나 동일한 이름을 사용하자!
      
      - **일반적으로 필드와 동일한 이름을 갖는 매개변수를 사용!**
      - 필드와 매개 변수 이름이 동일하기 때문에 생성자 내부에서 해당 필드에 접근할 수 없는 경우에는?
        - **this**를 필드 앞에 붙여라
          - this는 객체 자신의 참조, 객체가 객체 자신을 this라고 한다.
          - this.필드는 this라는 참조 변수로 필드를 사용하는 것과 동일.
  
  - **클래스에 생성자가 명시적으로 선언되어 있을 경우**에는 **반드시 선언된 생성자를 호출해서 객체를 생성해야만 한다!**

- **필드 초기화**
  
  - 클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정됨.
  
  - 필드를 기본 초기값이 아닌 다른 값으로 초기화하고 싶다면?
    
    **sol1) 필드 선언 시 초기값 주기**
    
    ex)
    
    ```java
    public class Korean {
    String nation = "대한민국";
    String name;
    String ssn;
    }
    
    Korean k1 = new Korean();
    Korean k2 = new Korean();
    ```
    
    - 동일한 클래스로부터 생성되는 객체들은 모두 같은 값을 갖게 됨.
    - 객체 생성 시점에는 필드의 값이 모두 같음.
      - 객체 생성 후에는 초기값 변경 가능.
    
    **sol2) 생성자에서 초기값 주기**
    
    ex)
    
    ```java
    public class Korean {
    //필드
    String nation = "대한민국";
    String name;
    String ssn;
    
    //생성자
    public Korean(String n, String s) {
        name = n;
        ssn = s;
        }
    }
    
    Korean k1 = new Korean("박자바", "011225-1234567");
    Korean k2 = new Korean("김자바", "930525-0654321");
    ```
    
    - 객체 생성 시점에 외부에서 제공되는 다양한 값들로 초기화되어야 한다면?
      
      → 생성자에서 초기화해야 한다!
  
  - 객체의 필드는 하나가 아니라 여러 개가 있고, 이 피드들을 모두 생성자에서 초기화한다면 생성자의 매개 변수 수는 객체의 필드 수만큼 선언되어야 한다. 그러나 실제로는 중요한 몇 개의 필드만 매개 변수를 통해 초기화되고 나머지 필드들은 필드 선언 시에 초기화하거나 생성자 내부에서 임의의 값 또는 계산된 값으로 초기화한다. 아니면 객체 생성 후에 필드값을 별도로 저장하기도 한다.

- **생성자 오버로딩**
  
  - 매개 변수를 달리하는 생성자를 여러 개 선언하는 것!
    
    - Why?
      
      - 외부에서 제공되는 다양한 데이터들을 이용해서 객체를 초기화하려면 생성자도 다양화될 필요가 있다!
      
      - 생성자가 하나뿐이라면 다양한 요구 조건 수용할 수 없다.
        
        ex) Car 객체 생성 시 model 데이터만 제공 or model, color 데이터가 제공되는 경우
  
  - **주의할 점** : 매개 변수의 타입과 개수, 그리고 선언된 순서가 똑같을 경우 매개 변수 이름만 바꾸는 것은 생성자 오버로딩이 아니다.
    
    ```java
    Car(String model, String color) { ... }
    Car(String color, String model) { ... } //오버로딩이 아님
    ```
  
  - 생성자가 오버로딩되어 있을 경우, new 연산자로 생성자를 호출할 때 제공되는 매개값의 타입과 수에 의해 호출될 생성자가 결정됨.

- **다른 생성자 호출 : `this()`**
  
  - 생성자 오버로딩이 많아질 경우, 생성자 간의 중복된 코드가 발생할 수 있다!
  
  - 이 경우, 필드 초기화 내용은 한 생성자에만 집중적으로 작성하고 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선할 수 있다.
    
    ```java
    클래스( [매개변수, ...]) {
        this( 매개변수, ..., 값, ...);   <- 클래스의 다른 새성자 호출
        실행문;
    }
    ```
    
    - **this()는 자신의 다른 생성자를 호출하는 코드로, 반드시 생성자의 첫 줄에서만 허용된다!**
    - this()의 매개값은 호출되는 생성자의 매개 변수에 맞게 제공해야 한다.
    - this() 다음에는 추가적인 실행문들이 올 수 있다.
      - 호출되는 생성자의 실행이 끝나면 원래 생성자로 돌아와서 다음 실행문을 진행한다는 뜻!

- **정리**
  
  - 기본 생성자
    - 클래스 선언 시 컴파일러에 의해 자동으로 추가되는 생성자
  - 생성자 선언
    - 클래스로부터 객체를 생성할 때 호출되는 생성자를 명시적으로 선언 가능
    - 생성자 선언 시 기본 생성자는 생성되지 않음
  - 매개 변수
    - 생성자 호출 시 값을 전달받기 위해 선언되는 변수
  - 객체 초기화
    - 객체를 사용하기 전에 준비하는 과정으로
    - 필드를 선언할 때 초기화하거나
    - 생성자 내부에서 필드값을 초기화할 수 있으며,
    - 메소드를 호출하는 내용으로 구성됨
  - 오버로딩
    - 매개 변수를 달리하는 생성자를 여러 개 선언하는 것
  - this()
    - 객체 자신의 또 다른 생성자를 호출할 때 사용
