## 🔶객체 지향 프로그래밍 (OOP : Object-Oriented Programming)

- **객체**
  - 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있으면서 식별 가능한 것.
  - 속성(필드)과 동작(메소드)으로 구성되어 있다.
  - 객체의 예시
    - 사람
      - 필드 : 이름, 나이 등..
      - 메소드 : 웃다, 걷다 등..
    - 자동차
      - 필드 : 색깔, 모델 등..
      - 메소드 : 달린다, 멈춘다 등

---

- **객체 모델링**
  - 현실 세계의 객체를 소프트웨어 객체로 설계하는 것
  - 현실 세계 객체의 속성과 동작을 소프트웨어 객체의 필드와 메소드로 정의하는 과정

---

- **객체의 상호작용**
  - 객체들은 각각 독립적으로 존재하고, 다른 객체와 서로 상호작용하면서 동작
    - **메소드** : 객체들 사이의 상호작용 수단
    - **메소드 호출** : 객체가 다른 객체의 기능을 이용하는 것
      - ex) 사람이 전자계산기를 사용한다면?
        - `**리턴값 = 전자계산기객체.메소드(매개값1, 매개값2, ...)**`
    - 객체의 상호작용은 객체 간의 메소드 호출을 의미하며 **매개값과 리턴값을 통해서 데이터를 주고받는다.**

---

- **객체 간의 관계**
  - 객체는 개별적으로 사용 가능. BUT 대부분 다른 객체와 관계를 맺고 있다.
  - 관계의 종류 : 집합 관계, 사용 관계, 상속 관계
    - ex) 집합 관계 : 부품과 자동차
    - ex) 사용 관계 : 사람과 자동차
    - ex) 상속 관계 : 기계와 자동차
  - 객체 지향 프로그래밍은 만들고자 하는 완성품인 객체를 모델링하고, 집합 관계에 있는 부품 객체와 사용 관계에 있는 객체를 하나씩 설계한 후 조립하는 방식으로 프로그램을 개발하는 기법

---

- **객체와 클래스**
  - 메모리에서 사용하고 싶은 객체가 있다면 우선 설계도로 해당 객체를 만드는 작업이 필요
  - 설계도가 바로 **클래스(class)**
    - 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있음
    - 클래스로부터 만들어진 객체를 해당 클래스의 **인스턴스**라고 함
  - 객체를 생성하는 순서
    - 개발자 —(설계)→ 클래스 —(인스턴스화)→ 인스턴스(객체)
  - 객체 지향 프로그래밍 개발의 3단계
    1. 클래스 설계
    2. 설계된 클래스를 가지고 사용할 객체 생성
    3. 생성된 객체를 이용

---

- **클래스 선언**
  
  - 사용하고자 하는 객체를 구상했다면, 그 객체의 대표 이름을 하나 결정하고 이것을 클래스 이름으로 정한다.
  
  - 자바의 클래스 이름은 다른 클래스와 식별할 목적이므로 식별자 작성 규칙에 따르자!
    
    - 식별자 작성 규칙
      - 하나 이상의 문자로 이루어져야 한다.
      - 첫 글자에는 숫자가 올 수 없다.
      - $, _ 외의 특수 문자는 사용할 수 없다.
      - 자바 키워드는 사용할 수 없다.
  
  - 클래스 이름을 정했다면 “클래스 이름.java”로 소스 파일을 생성.
    
    - 소스 파일 이름도 대소문자 구분하므로 반드시 클래스 이름과 대소문자가 같도록 하기
    
    ```java
    public class 클래스이름 {
    
    }
    ```
    
    - public class 키워드는 클래스를 선언할 때 사용, 반드시 소문자로!
    - { : 클래스 선언의 시작
    - } : 클래스 선언의 끝
  
  - 일반적으로 소스 파일당 하나의 클래스 선언. BUT 2개 이상의 클래스 선언도 가능
    
    - 소스 파일은 클래스 선언을 담고 있는 저장 단위일 뿐, 클래스 자체가 아님
  
  - 참고) `public 접근 제한자`
    
    - public 접근 제한자는 파일 이름과 동일한 이름의 클래스 선언에만 붙일 수 있다.
    - 파일 이름과 일치하지 않는 클래스 선언에 붙이면 컴파일 에러가 발생
    - 따라서 가급적 소스 파일 하나당 동일한 이름의 클래스 하나만 선언하자!

---

- **객체 생성과 클래스 변수**
  
  - 클래스로부터 객체를 생성하려면?
    
    - new 연산자 사용하기
      
      - `new 클래스();`
      
      - new 연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다.
      
      - new 연산자로 생성된 객체는 메모리 힙 영역에 생성된다.
        
        - new 연산자는 힙 영역에 객체 생성 후 객체의 번지를 리턴한다. (객체의 위치를 모르면 사용할 수 없기 때문에!)
        
        - **이 주소를 참조 타입인 클래스 변수에 저장해두면 변수를 통해 객체를 사용할 수 있다.**
          
          ```java
          방법 1)
          클래스 변수;
          변수 = new 클래스();
          
          방법 2)
          클래스 변수 = new 클래스();
          ```

---

- **클래스의 용도(2가지)**
  - 라이브러리용 & 실행용
  - 라이브러리 클래스 : 다른 클래스에서 이용할 목적으로 설계됨
  - 실행 클래스 : 프로그램의 실행 진입점인 main() 메소드를 제공하는 역할을 함.
    - 프로그램 전체에서 사용되는 클래스가 100개라면 99개는 라이브러리 클래스, 1개가 실행 클래스
  - 대부분의 객체 지향 프로그램은 **라이브러리(부품 객체 및 완성 객체)**와 **실행 클래스**가 분리되어 있음

---

- **클래스의 구성 멤버**
  - 클래스에는 객체가 가져야 할 구성 멤버가 선언됨.
    - 구성 멤버
      1. 필드 (Field)
         - 객체의 데이터가 저장되는 곳
         - 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳
         - 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재
           - 비교) 변수는 생성자와 메소드 내에서만 사용, 생성자와 메소드가 실행 종료되면 자동 소멸
      2. 생성자 (Constructor)
         - 객체 생성 시 초기화 역할 담당
         - new 연산자로 호출되는 특별한 { } 블록
      3. 메소드 (Method)
         - 객체의 동작에 해당하는 실행 블록(중괄호 블록)
         - 메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행됨

---

## 필드

- **필드**
  - 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장하는 곳
  - ex) 자동차 객체
    - 고유 데이터 : 제작회사, 모델, 색깔, 최고 속도
    - 상태 데이터 : 현재 속도, 엔진 회전 수
    - 부품 : 차체, 엔진, 타이어
    - **위 정보들은 자동차 클래스를 설계할 때 필드로 선언되어야 한다.**

---

- **필드 선언**
  
  - 클래스 중괄호 {} 블록 어디서든 존재할 수 있다.
  
  - **BUT** 생성자와 메소드 중괄호 {} 브록 내부에는 선언될 수 없다
    
    - 생성자와 메소드 중괄호 블록 내부에 선언된 것은 모두 로컬 변수가 되기 때문!
  
  - 필드 선언은 변수의 선언 형태와 비슷
    
    - 일부 사람들은 클래스 멤버 변수라고 부름. 하지만 될 수 있으면 필드라는 용어 그대로 사용하자!
  
  - `타입 필드 [ = 초기값 ]`
    
    - 선언 형태는 변수와 비슷하지만, 필드를 변수라고 부르지는 않는다!
    - 타입은 필드에 저장할 데이터의 종류를 결정
      - 기본 타입(byte, short, int, long, float, double, boolean), 참조 타입(배열, 열거, 인터페이스) 이 모두 올 수 있음
      - 필드의 초기값은 필드 선언 시 주어질 수도 있고, 생략될 수도 있음
    - 올바르게 필드를 선언한 예시
    
    ```java
    String company = "현대자동차";
    String model = "그랜저";
    int maxSpeed = 300;
    int productionYear;
    int currentSpeed;
    boolean engineStart;
    ```
    
    - 초기값이 지정되지 않은 필드는 객체 생성 시 자동으로 기본 초기값으로 설정됨
      - 기본 타입
        - 정수 타입
          - byte : 0
          - char : \u0000 (빈 공백)
          - short : 0
          - int : 0
          - long : 0L
        - 실수 타입
          - float : 0.0F
          - double : 0.0
        - 논리 타입
          - boolean : false
      - 참조 타입
        - 배열 : null
        - 클래스(String 포함) : null
        - 인터페이스 : null

---

- **필드 사용**
  - 필드값을 읽고 변경하는 작업
  - 클래스 내부의 생성자나 메소드에서 사용할 경우
    - 단순히 필드 이름으로 읽고 변경
  - 클래스 외부에서 사용할 경우
    - 클래스로부터 객체를 생성한 뒤 필드를 사용해야 한다.
      - 필드가 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않기 때문이다!!

---

- **정리**
  - 필드 선언 : 클래스 중괄호 {} 블록 어디서든 선언하나, 생성자와 메소드 내부에서는 선언할 수 없다.
  - 필드 사용 : 클래스 내부의 생성자와 메소드에서 바로 사용이 가능하나, 클래스 외부에서 사용할 경우에는 반드시 객체를 생성하고 참조 변수를 통해 사용해야 한다.

---

## 생성자

- **개요**
  - 생성자란?
    - new 연산자로 호출되는 중괄호 {} 블록
    - 객체 생성 시 초기화를 담당
    - 모든 클래스에 **반드시 하나 이상** 존재
      - **클래스 내부에 선언을 생략하면 기본 생성자가 자동으로 추가됨.**

---

- **생성자(Constructor)**
  - new 연산자로 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당
    - 객체 초기화
      - 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 하는 것
  - 생성자를 실행하지 않고는 클래스로부터 객체를 만들 수 없다!
    - 생성자가 성공적으로 실행되지 않고 예외(에러)가 발생했다면 객체는 생성되지 않는다.
  - new 연산자에 의해 생성자가 성공적으로 실행되면
    1. 힙(heap) 영역에 객체가 생성됨.
    2. 객체의 번지가 리턴됨.
    3. 리턴된 객체의 번지는 클래스 변수에 저장됨.

---

- **기본 생성자**
  
  - 모든 클래스에는 생성자가 반드시 하나 이상 존재
    
    - 클래스 내부에 생성자 선언을 생략했다면?
      
      → 컴파일러는 중괄호 {} 블록 내용이 비어 있는 **기본 생성자**를 바이트 코드에 자동 추가
      
      `[public] 클래스() {}`
      
      - 클래스가 public class로 선언되면 기본 생성자에도 public이 붙음
      - 클래스가 public 없이 class로만 선언되면 기본 생성자에도 public이 붙지 않음
      
      ex)
      
      ```java
      소스 파일(Car.java)
      public class Car {
      }
      
      -> 컴파일 ->
      
      바이트 코드 파일(Car.class)
      public class Car {
          public Car() { } //자동 추가
      }
      ```
      
      - 따라서 클래스에 생성자를 선언하지 않아도 new 연산자 뒤에 기본 생성자를 호출해서 객체 생성 가능
        
        ex) `Car myCar = new Car();`
  
  - 명시적으로 선언한 생성자가 1개라도 있으면 컴파일러는 기본 생성자를 추가하지 않는다.
    
    - 명시적으로 생성자를 선언하는 이유는?
      
      → 객체를 다양한 값으로 초기화하기 위해서!
      
      그렇다면 이제 생성자를 명시적으로 선언하는 방법을 공부해보자!!

---

- **생성자 선언**
  
  - 기본 생성자 대신 명시적으로 선언하려면 다음과 같이 하자!
  
  ```java
  클래스( 매개변수 선언, ...) {
      //객체의 초기화 코드
  }
  ```
  
  - 생성자는 메소드와 비슷한 모양을 가지고 있으나, 리턴 타입이 없고 클래스 이름과 동일
  
  - 생성자 블록 내부에는 객체 초기화 코드가 작성됨
    
    - 일반적으로 필드에 초기값을 저장하거나
    - 메소드를 호출하여 객체 사용 전에 필요한 준비를 함
  
  - 매개변수 선언은 생략할 수도 있고 여러 개를 선언할 수도 있다.
    
    - 매개변수의 역할은?
      
      - new 연산자로 생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달하는 역할을 함.
      
      ex) `Car myCar = new Car("그랜저", "검정", 300);`
      
      - 2개의 매개값은 String 타입, 마지막 매개값은 int 타입
      - 세 매개값을 생성자가 받기 위해서는 다음과 같이 매개 변수를 선언해야 한다.
      
      ```java
      public class Car {
          //생성자
          Car(String model, String color, int maxSpeed) { ... }
      }
      ```
    
    - 매개 변수의 이름이 너무 짧으면 코드의 가독성이 좋지 않기 때문에, 가능하면 초기화시킬 필드 이름과 비슷하거나 동일한 이름을 사용하자!
      
      - **일반적으로 필드와 동일한 이름을 갖는 매개변수를 사용!**
      - 필드와 매개 변수 이름이 동일하기 때문에 생성자 내부에서 해당 필드에 접근할 수 없는 경우에는?
        - **this**를 필드 앞에 붙여라
          - this는 객체 자신의 참조, 객체가 객체 자신을 this라고 한다.
          - this.필드는 this라는 참조 변수로 필드를 사용하는 것과 동일.
  
  - **클래스에 생성자가 명시적으로 선언되어 있을 경우**에는 **반드시 선언된 생성자를 호출해서 객체를 생성해야만 한다!**

---

- **필드 초기화**
  
  - 클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정됨.
  
  - 필드를 기본 초기값이 아닌 다른 값으로 초기화하고 싶다면?
    
    **sol1) 필드 선언 시 초기값 주기**
    
    ex)
    
    ```java
    public class Korean {
    String nation = "대한민국";
    String name;
    String ssn;
    }
    
    Korean k1 = new Korean();
    Korean k2 = new Korean();
    ```
    
    - 동일한 클래스로부터 생성되는 객체들은 모두 같은 값을 갖게 됨.
    - 객체 생성 시점에는 필드의 값이 모두 같음.
      - 객체 생성 후에는 초기값 변경 가능.
    
    **sol2) 생성자에서 초기값 주기**
    
    ex)
    
    ```java
    public class Korean {
    //필드
    String nation = "대한민국";
    String name;
    String ssn;
    
    //생성자
    public Korean(String n, String s) {
        name = n;
        ssn = s;
        }
    }
    
    Korean k1 = new Korean("박자바", "011225-1234567");
    Korean k2 = new Korean("김자바", "930525-0654321");
    ```
    
    - 객체 생성 시점에 외부에서 제공되는 다양한 값들로 초기화되어야 한다면?
      
      → 생성자에서 초기화해야 한다!
  
  - 객체의 필드는 하나가 아니라 여러 개가 있고, 이 피드들을 모두 생성자에서 초기화한다면 생성자의 매개 변수 수는 객체의 필드 수만큼 선언되어야 한다. 그러나 실제로는 중요한 몇 개의 필드만 매개 변수를 통해 초기화되고 나머지 필드들은 필드 선언 시에 초기화하거나 생성자 내부에서 임의의 값 또는 계산된 값으로 초기화한다. 아니면 객체 생성 후에 필드값을 별도로 저장하기도 한다.

---

- **생성자 오버로딩**
  
  - 매개 변수를 달리하는 생성자를 여러 개 선언하는 것!
    
    - Why?
      
      - 외부에서 제공되는 다양한 데이터들을 이용해서 객체를 초기화하려면 생성자도 다양화될 필요가 있다!
      
      - 생성자가 하나뿐이라면 다양한 요구 조건 수용할 수 없다.
        
        ex) Car 객체 생성 시 model 데이터만 제공 or model, color 데이터가 제공되는 경우
  
  - **주의할 점** : 매개 변수의 타입과 개수, 그리고 선언된 순서가 똑같을 경우 매개 변수 이름만 바꾸는 것은 생성자 오버로딩이 아니다.
    
    ```java
    Car(String model, String color) { ... }
    Car(String color, String model) { ... } //오버로딩이 아님
    ```
  
  - 생성자가 오버로딩되어 있을 경우, new 연산자로 생성자를 호출할 때 제공되는 매개값의 타입과 수에 의해 호출될 생성자가 결정됨.

---

- **다른 생성자 호출 : `this()`**
  
  - 생성자 오버로딩이 많아질 경우, 생성자 간의 중복된 코드가 발생할 수 있다!
  
  - 이 경우, 필드 초기화 내용은 한 생성자에만 집중적으로 작성하고 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선할 수 있다.
    
    ```java
    클래스( [매개변수, ...]) {
        this( 매개변수, ..., 값, ...);   <- 클래스의 다른 새성자 호출
        실행문;
    }
    ```
    
    - **this()는 자신의 다른 생성자를 호출하는 코드로, 반드시 생성자의 첫 줄에서만 허용된다!**
    - this()의 매개값은 호출되는 생성자의 매개 변수에 맞게 제공해야 한다.
    - this() 다음에는 추가적인 실행문들이 올 수 있다.
      - 호출되는 생성자의 실행이 끝나면 원래 생성자로 돌아와서 다음 실행문을 진행한다는 뜻!

---

- **정리**
  - 기본 생성자
    - 클래스 선언 시 컴파일러에 의해 자동으로 추가되는 생성자
  - 생성자 선언
    - 클래스로부터 객체를 생성할 때 호출되는 생성자를 명시적으로 선언 가능
    - 생성자 선언 시 기본 생성자는 생성되지 않음
  - 매개 변수
    - 생성자 호출 시 값을 전달받기 위해 선언되는 변수
  - 객체 초기화
    - 객체를 사용하기 전에 준비하는 과정으로
    - 필드를 선언할 때 초기화하거나
    - 생성자 내부에서 필드값을 초기화할 수 있으며,
    - 메소드를 호출하는 내용으로 구성됨
  - 오버로딩
    - 매개 변수를 달리하는 생성자를 여러 개 선언하는 것
  - this()
    - 객체 자신의 또 다른 생성자를 호출할 때 사용

---

## 메소드

- **메소드**란?
  - 객체의 동작에 해당하는 중괄호 {} 블록
    - 중괄호 {} 블록 이름이 메소드 이름
    - 메소드를 호출하면 중괄호 블록에 잇는 모든 코드들이 일괄적으로 실행됨

---

- **개요**
  
  - 메소드 선언
    
    = 선언부 + 실행 블록
    
    - 메소드 선언부를 **메소드 시그니처**라고 한다.
    
    - 선언부와 실행 블록의 요소
      
      - 리턴 타입 : 메소드가 리턴하는 결과의 타입을 표시
      - 메소드 이름 : 메소드의 기능이 드러나도록 식별자 규칙에 맞게 이름을 지어줌
      - 매개 변수 선언 : 메소드를 실행할 때 필요한 데이터를 받기 위한 변수를 선언
      - 메소드 실행 블록 : 실행할 코드를 작성
      
      ```java
      리턴타입 메소드 이름 ([매개변수선언, ...]) {
      
              메소드 실행 블록
      
      }
      ```

---

- **메소드 선언**
  - 선언부(리턴 타입, 메소드 이름, 매개 변수 선언)와 실행 블록으로 구성
  - 리턴 타입
    - 리턴값의 타입
      - 리턴값 : 메소드를 실행한 후의 결과값
    - 리턴값이 있을 수도 있고 없을 수도 있으나 있을 경우엔 리턴 타입이 선언부에 명시되어있어야 함
      - `void` : 리턴값이 없는 메소드의 리턴 타입
    - 리턴값의 유무에 따라 메소드를 호출하는 방법이 다르다.
  - 메소드 이름
    - 자바 식별자 규칙에 맞게 작성
      - 숫자로 시작 x
      - $와 _를 제외한 특수 문자 사용 x
      - 관례적으로 소문자로 시작
      - 서로 다른 단어가 혼합된 이름이라면 뒤이어 오는 단어의 첫 글자는 대문자
    - 메소드가 어떤 기능을 수행하는지 쉽게 알 수 있도록 기능 이름으로 지어주는 것이 좋음
    - 메소드 이름의 길이는 프로그램 실행과는 무관하니, 너무 짧게 하지 말자!

---

- **매개 변수 선언**
  
  - 메소드가 실행할 떄 필요한 데이터를 외부로부터 받기 위해 사용됨
  
  ex) `double divide( int x, int y ) { ... }`
  
  - 이렇게 선언된 divide() 메소드를 호출할 때에는 반드시 2개의 int 값을 주어야 함
  
  - **매개값은 반드시 매개 변수의 타입에 부합되는 값이어야 한다!**
  
  - 매개 변수의 개수를 모를 경우
    
    → 매개 변수를 **배열 타입**으로 선언
    
    ex) `int sum1(int[] values) { }`
    
    - sum1() 메소드를 호출할 때 배열을 넘겨줌으로써 배열의 항목 값들을 모두 전달할 수 있음
    
    ```java
    int[] values = {1, 2, 3};
    int result = sum1(values);
    int result = sum1(new int[] { 1, 2, 3, 4, 5 });
    ```
    
    - 매개 변수를 배열 타입으로 선언하면 메소드를 호출하기 전에 배열을 생성해야 하는 불편한 점이 있음
      
      따라서 배열을 생성하지 않고 값의 목록만 넘겨주는 방법도 있음!!!!!
      
      ```java
      int sum2(int ⋯ values) { }
      ```
      
      - 메소드의 매개 변수를 **⋯**를 사용해서 선언하게 되면 메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용됨!
      
      - **⋯**로 선언된 매개 변수의 값은 다음과 같이 메소드 호출 시 쉼표로 나열하면 됨
        
        ```java
        int result = sum2(1, 2, 3);
        int result = sum2(1, 2, 3, 4, 5);
        ```
      
      - **⋯⋯**로 선언된 매개 변수는 배열 타입이므로 다음과 같이 배열을 직접 매개값으로 사용해도 좋음
        
        ```java
        int[] values = { 1, 2, 3 };
        int result = sum2(values);
        int result = sum2(new int[] { 1, 2, 3, 4, 5 });
        ```

---

- **리턴(return)문**
  - 메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴문을 사용해서 리턴값을 지정해야 함
    - `return 리턴값;`
    - return문이 없다면? → 컴파일 에러
    - return문이 실행 → 메소드 즉시 종료
      - return문 이후의 실행문은 결코 실행되지 않는다.
        - return 이후에 실행문이 오면 컴파일 에러 발생
          - Unreachable code
  - 리턴값은 리턴 타입이거나 리턴 타입으로 변환될 수 있어야 함

---

- **리턴값이 없는 메소드 : `void`**
  - void로 선언된 메소드에서도 return문 사용 가능
    - `return;`
    - 리턴값을 지정하는 역할 X
    - 메소드 실행을 강제 종료시키는 역할 O

---

- **메소드 호출**
  
  - 메소드는 클래스 내, 외부의 호출에 의해 실행됨
    
    - 클래스 내부의 다른 메소드에서 호출할 경우
      
      - 단순한 메소드 이름으로 호출
    
    - 클래스 외부에서 호출할 경우
      
      1. 클래스로부터 객체를 생성
      
      2. 참조 변수를 이용해서 메소드 호출
      - 객체가 존재해야 메소드도 존재하므로…!
  
  ---
  
  - **객체 내부에서의 호출**
    - 클래스 내부에서 다른 메소드를 호출할 경우에는 다음과 같은 형태로 작성
      - `**메소드( 매개값, ... );**`
    - 리턴값이 있는 메소드를 호출하고 리턴값을 받고 싶다면 다음과 같이 변수를 선언하고 리턴값을 대입하자!
      - **`타입 변수 = 메소드( 매개값, ... );`**
      - 변수 타입은 메소드 리턴 타입과 동일하거나, 자동 타입 변환이 될 수 있어야 한다!
  
  ---
  
  - **객체 외부에서의 호출**
    - 외부 클래스에서 메소드를 호출하려면 우선 클래스로부터 객체를 생성해야 함.
      - 메소드는 객체에 소속된 멤버이므로 객체가 존재 X → 메소드도 존재 X
      - `**클래스 참조변수 = new 클래스( 매개값, ... );**`
    - 객체가 생성되었다면 참조 변수와 함께 도트(.) 연산자를 사용해서 메소드 호출
      - 도트(.) 연산자란?
        - 객체 접근 연산자로 객체가 가지고 있는 필드나 메소드에 접근할 때 사용됨
      - `**참조변수.메소드( 매개값, ... );**`
        - 리턴값이 없거나, 있어도 리턴값을 받지 않을 경우
      - `**타입 변수 = 참조변수.메소드( 매개값, ... );**`
        - 리턴값이 있고, 리턴값을 받고 싶을 경우

---

- **메소드 오버로딩**
  
  - 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것
  
  - 오버로딩이란?
    
    - 사전적 의미 : 많이 싣는 것
    - 하나의 메소드 이름으로 여러 기능을 담는다 하여 붙여진 이름
  
  - 메소드 오버로딩의 조건
    
    1. 매개 변수의 **타입**
    
    2. 매개 변수의 **개수**
    
    3. 매개 변수의 **순서**
    - 위 3가지 중 하나가 달라야 한다!!!
  
  - 왜 쓰는 걸까?
    
    - 매개값을 다양하게 받아 처리할 수 있도록 하기 위해!!!
  
  - 주의할 점
    
    - 매개 변수의 타입과 개수, 순서가 똑같을 경우 매개 변수 이름이 다르다고 해서 이것을 메소드 오버로딩이라고 하지 않는다!!!
    - 리턴 타입만 다르고 매개 변수가 동일하다면 오버로딩이 아니다!!!

---

- **정리**
  
  - 선언부
    - 메소드 선언부는 리턴 타입, 메소드 이름, 매개 변수 선언 부분
  - void
    - 리턴값이 없는 메소드는 리턴 타입으로 void를 기술해야 함
  - 매개 변수
    - 메소드 호출 시 제공되는 매개값은 메소드 선언부의 매개 변수에 차례대로 대입되어, 메소드 블록 실행 시 이용됨
  - 리턴문
    - 메소드 선언부에 리턴 타입이 있다면 리턴값을 지정하기 위해 return문 반드시 필요
    - 리턴 타입이 void라면 return문 필요 X
      - 메소드 실행 종료를 위해 사용 가능
  - 호출
    - 메소드를 실행하려면 → `메소드 이름(매개값, ...)` 형태로 호출
  - 오버로딩
    - 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것
    - 메소드 오버로딩의 조건
      - 매개 변수의 타입, 개수, 순서 중 하나가 달라야 한다!
  
  ---

## 인스턴스 멤버와 정적 멤버

- **개요**
  - 클래스에 선언된 필드와 메소드가 모두 객체 내부에 포함되는 것은 아님
  - 일부는 포함이 되겠지만, 포함이 되지 않고 클래스에 그대로 남아 있는 것도 있다!!!
  - 따라서 **클래스 멤버(필드, 메소드)**를 **인스턴스 멤버와 정적 멤버로 구분해서 선언**!!!
    - **인스턴스 멤버** : 객체마다 가지고 있는 멤버
    - **정적 멤버** : 클래스에 위치시키고 객체들이 공유하는 멤버

---

- **인스턴스 멤버**
  - 객체(인스턴스)를 생선한 후 사용할 수 있는 필드와 메소드
    - 각각 인스턴스 필드, 인스턴스 메소드라고 부름
  - 객체에 소속된 멤버이기 때문에 객체 없이는 사용할 수 없음
- **this**
  - 객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는 것과 마찬가지로 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있음
  - `**this.model**` 은 자신이 가지고 있는 model 필드라는 뜻
  - 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용됨.

---

- **정적 멤버와 static**
  
  - 정적(static)이란?
    
    - 고정된
  
  - 정적 멤버는 클래스에 고정된 멤버로서 **객체를 생성하지 않고 사용할 수 있는** 필드와 메소드
    
    - 이들을 각각 정적 필드, 정적 메소드라고 부름
  
  - 정적 멤버 선언은?
    
    - 필드와 메소드 선언 시 static 키워드를 추가적으로 붙이면 됨
    
    - 필드를 선언할 때 인스턴스 필드와 정적 필드 중 무엇으로 선언할 것인지 판단 기준이 필요
      
      - 객체마다 가지고 있어야 할 데이터라면?
        
        → **인스턴스 필드**
      
      - 객체마다 가지고 있을 필요가 없는 공용 데이터라면?
        
        → **정적 필드**
    
    - 메소드를 선언할 때 인스턴스 메소드와 정적 메소드 중 무엇으로 선언할 것인지 판단 기준이 필요
      
      - 인스턴스 필드를 포함하고 있다면?
        
        → **인스턴스 메소드**
      
      - 인스턴스 필드를 포함하고 있지 않다면?
        
        → **정적 메소드**
  
  - 정적 멤버 사용
    
    - 클래스 이름과 함께 도트(.) 연산자로 접근
      
      `클래스.필드;`
      
      `클래스.메소드( 매개값, ... );`
      
      ```java
      public class Calculator {
          static double pi = 3.14159;
          static int plus(int x, int y) { ... }
          static int minus(int x, int y) { ... }
      }
      
      정적 필드 pi, 정적 메소드 plus(), minus()는 다음과 같이 사용 가능
      double result1 = 10 * 10 * Calculator.pi;
      int result2 = Calculator.plus(10, 5);
      int result3 = Calculator.minus(10, 5);
      ```
    
    - 원칙적으로는 클래스 이름으로 접근해야 하지만 객체 참조 변수로도 접근이 가능
      
      ```java
      Calculator myCalcu = new Calculator();
      double result1 = 10 * 10 * myCalcu.pi;
      int result2 = myCalcu.plus(10, 5);
      int result3 = myCalcu.minus(10, 5);
      ```
      
      하지만 정적 요소는 클래스 이름으로 접근하는 것이 좋다
      
      - 이클립스에서는 객체 참조 변수로 접근했을 시 경고 표시가 나타남!
  
  - 정적 메소드 선언 시 주의할 점
    
    - 객체가 없어도 실행된다는 특징 때문에 정적 메소드를 선언할 때는 이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다.
      - **인스턴스 멤버를 사용하고 싶다면 객체를 먼저 생성하고 참조 변수로 접근해야 함!!**
      - main() 메소드도 정적 메소드이므로 객체 생성 없이 인스턴스 멤버를 바로 사용할 수 없다!
    - 객체 자신의 참조인 this 키워드 사용이 불가능하다.

---

- **싱글톤**
  
  - 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우 존재
    - 단 하나만 생성된다고 해서 이 객체를 싱글톤(Singleton)이라고 함
  - 싱글톤을 만들려면, 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 함!
    - 생성자를 외부에서 호출할 수 없도록 하려면,
      1. **생성자 앞에 private 접근 제한자를 붙이기**
      2. **자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화하기**
         - 정적 필드도 private 접근 제한자를 붙여 외부에서 필드값을 변경하지 못하도록 막기
  
  ```java
  public class 클래스 {
      //정적 필드
      private static 클래스 singleton = new 클래스();
  
      //생성자
      private 클래스() {}
  
      //정적 메소드
      static 클래스 getInstance() {
          return singleton;
      }
  }
  ```

---

- **final 필드와 상수**
  - **final 필드**
    - 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없다는 것
    - 선언 방법 : `final 타입 필드 [ = 초기값 ];`
    - 초기값 줄 수 있는 방법은 오로지 두 가지
      1. 필드 선언 시에 주는 방법
         1. 단순 값이라면 필드 선언 시에 주는 것이 간단
      2. 생성자에서 주는 방법
         1. 복잡한 초기화 코드가 필요하거나 객체 생성 시에 외부 데이터로 초기화해야 한다면 생성자에서 초기값 지정해야 함
         2. 생성자는 final 필드의 최종 초기화를 마쳐야 함. 만약 초기화되지 않은 final 필드를 그래도 남겨 두면 컴파일 에러 발생

---

- **상수**
  
  - 상수란?
    
    - 일반적으로 불변의 값을 상수(static final)이라고 부름.
      - ex) 원주율 파이, 지구의 무게 및 둘레 등
    - 이런 불변의 값을 저장하는 필드를 자바에서는 상수(constant)라고 함
  
  - final 필드 vs 상수
    
    - final 필드는 한 번 초기화되면 수정할 수 없는 필드. **BUT** 상수라고 부르지 않음!!
      - 불변의 값은 객체마다 저장할 필요가 없는 공용성 가짐
      - 여러 가지 값으로 초기화될 수 없음
    - final 필드는 객체마다 저장되고, 생성자의 매개값을 통해서 여러 가지 값을 가질 수 있기 때문에 상수가 될 수 없다!
  
  - 불변의 값은 객체마다 저장할 필요가 없는 공용성 가지므로
    
    → 상수는 static이며 final이다!!!
    
    → **static final 필드는 객체마다 존재하지 않고 클래스에만 존재**
    
    → 한 번 초기값이 저장되면 변경 불가
    
    `static final 타입 상수 = 초기값;`
    
    - 상수 이름은 모두 대문자로 작성하는 것이 관례
      - 서로 다른 단어가 혼합된 이름이라면 언더바(_)로 단어들 연결하기

---

- **정리**
  - 인스턴스 멤버
    - 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데, 이들을 각각 인스턴스 필드와 인스턴스 메소드라고 부름
  - this
    - 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this 사용 가능
    - ex) this.model : 자신이 가지고 있는 model 필드
    - 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용
  - 정적 멤버
    - 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말하고, 이들을 각각 정적 필드, 정적 메소드라고 부름
  - static
    - 정적 멤버를 선언할 때 사용하는 키워드
  - 싱글톤
    - 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우, 단 하나만 생성되는 객체를 싱글톤이라 함
  - final 필드
    - 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없는 필드.
    - final 키워드로 선언
  - 상수
    - 원주율 파이나 지구의 무게 및 둘레 같은 불변의 값을 저장하는 필드를 자바에서는 상수라고 부름.
    - final static 키워드로 선언

---

## 패키지와 접근 제한자

- **개요**
  - 패키지의 기능
    1. 파일 시스템의 폴더 기능
    2. 클래스의 일부분.
       - 클래스를 유일하게 만들어주는 식별자 역할을 함.
         - 클래스 이름이 동일하더라도 패키지가 다르면 다른 클래스로 인식.
       - 클래스의 전체 이름 : `패키지 이름 + 클래스 이름`
         - 패키지가 상, 하위로 구분되어 있다면? → 도트(.) 사용해서 표현
           - `상위패키지.하위패키지.클래스`

---

- **패키지 선언**
  
  - 패키지 선언이란?
    
    - 클래스를 작성할 때 해당 클래스가 어떤 패키지에 속할 것인지를 선언하는 것
    
    ```java
    package 상위패키지.하위패키지;
    
    public class ClassName { ... }
    ```
  
  - 패키지는 클래스의 일부
    
    - 클래스만 따로 복사해서 다른 곳으로 이동하면 클래스를 사용할 수 없기 때문
      - 클래스를 이동해야 한다면 패키지 전체를 이동시켜야 함!!!
  
  - 패키지 이름 규칙
    
    - 숫자로 시작 x
    - _, $를 제외한 특수 문자 사용 x
    - java로 시작하는 패키지는 자바 표준 API에서만 사용하므로 사용 x
    - 모두 소문자로 작성 (관례)
  
  - 이클립스는 패키지 선언이 없는 클래스를 default 패키지에 포함시킴
    
    - default 패키지는 사실상 패키지가 없다는 뜻

---

- **import문**
  
  - 사용하고자 하는 클래스 또는 인터페이스가 다른 패키지에 소속되어 있다면, import문으로 해당 패키지의 클래스 또는 인터페이스를 가져와 사용할 것임을 컴파일러에게 알려줘야 함
  
  ```java
  import 상위패키지.하위패키지.클래스이름;
  import 상위패키지.하위패키지.*;
  ```
  
  - import문은 패키지 선언과 클래스 선언 사이에 작성
  
  - 사용하고자 하는 클래스들이 동일한 패키지 소속이라면?
    
    → 개별 import문을 작성하는 것보다 *를 이용하자!!
  
  - import문은 개수에 제한이 없고 얼마든지 추가 가능함
  
  - **주의할 점**
    
    - 상위 패키지를 import했다고 해서 하위 패키지까지 import 되는 것은 아니다!
      
      - 자바는 패키지 전체 이름으로 패키지를 식별하기 때문에 com.hankook과 com.hankook.project를 서로 다른 패키지로 인식함
      
      - 따라서 위 두 패키지에 소속된 클래스를 사용하려면
        
        ```java
        import com.hankook.*;
        import com.hankook.project.*;
        ```
        
        위와 같이 2개의 import문이 필요함
  
  - 경우에 따라서 import문과 상관없이 패키지가 포함된 클래스 전체 이름을 코드에 기술해야 할 때가 있음
    
    - 서로 다른 패키지에 동일한 클래스 이름이 존재하고, 두 패키지가 모두 import 되면, 컴파일러는 어떤 패키지의 클래스를 사용해야 할 지 모호해지므로 컴파일 에러를 발생시킴
    
    ex) `sec06.exam02.hankook` 과 `sec06.exam02.kumho` 에 [`Tire.java`](http://Tire.java) 존재
    
    ```java
    package sec06.exam02.hyundai;
    
    import sec06.exam02.hankook.*;
    import sec06.exam02.kumho.*;
    import sec06.exam02.hyundai.Engine;
    
    public class Engine {
    
        //필드
        Engine engine = new Engine();
        SnowTire tire1 = new SnowTire();
        BigWidthTire tire2 = new BigWidthTire();
        sec06.exam02.hankook.Tire tire3 = new sec06.exam02.hankook.Tire();
        sec06.exam02.kumho.Tire tire4 = new sec06.exam02.kumho.Tire();
    
    }
    ```
    
    Tire 클래스는 import된 두 패키지(hankook, kumho)에 모두 있기 때문에 패키지 이름과 함께 전체 이름이 기술되어야 한다!

---

- **접근 제한자**
  
  - 접근을 제한하기 위해 사용
    
    - 접근이란?
      - 클래스 및 인터페이스 그리고 이들이 가지고 있는 멤버의 접근
    - 언제 사용?
      - 클래스와 인터페이스를 다른 패키지에서 사용 못하도록 함
      - 객체 생성을 막기 위해 생성자를 호출하지 못하게 함
      - 필드나 메소드를 사용하지 못하게 함
  
  - 종류
    
    1. `**public 접근 제한자**`
       - 외부 클래스가 자유롭게 사용할 수 있도록 함
    2. `**protected 접근 제한자**`
       - 같은 패키지 또는 자식 클래스에서 사용할 수 있도록 함
    3. `**private 접근 제한자**`
       - 개인적인 것이라 외부에서 사용될 수 없도록 함
    - 위 세 가지 접근 제한자가 적용되지 않다면?
      
      **→ `default 접근 제한`**
      
      - 같은 패키지에 소속된 클래스에서만 사용 가능
    
    - private < default < protected < public

---

- **클래스의 접근 제한**
  
  - 클래스를 선언할 때 해당 클래스를 같은 패키지 내에서만 사용할 것인지, 아니면 다른 패키지에서도 사용할 수 있도록 할 것인지 결정해야 함!!!
  
  - 클래스는 다음과 같이 public, default 접근 제한을 가짐
    
    ```java
    //default 접근 제한
    class 클래스 { ... }
    
    //public 접근 제한
    public class 클래스 { ... }
    ```
    
    - default 접근 제한
      - 클래스를 선언할 때 public을 생략한 경우
      - 같은 패키지에서만 아무런 제한 없이 사용 가능, 다른 패키지에서는 사용 불가능
    - public 접근 제한
      - 같은 패키지 뿐만 아니라 다른 패키지에서도 아무런 제한 없이 사용 가능
      - 다른 개발자가 사용할 수 있도록 라이브러리 크래스로 개발한다면 반드시 public 접근 제한을 가져야!!!

---

- **생성자의 접근 제한**
  
  - 객체 생성 위해 new 연산자로 생성자를 호출. 하지만 생성자를 어디에서나 호출할 수 있는 것은 아님. 생성자가 어떤 접근 제한을 갖느냐에 따라 호출 가능 여부가 결정됨!!!
  
  - public, protected, default, private 접근 제한을 가짐
    
    ```java
    public class ClassName {
        //public 접근 제한
        public ClassName(...) { ... }
    
        //protected 접근 제한
        protected ClassName(...) { ... }
    
        //default 접근 제한
        default ClassName(...) { ... }
    
        //private 접근 제한
        private ClassName(...) { ... }
    }
    ```
  
  - 클래스에 생성자를 선언하지 않으면 컴파일러에 의해 자동으로 기본 생성자가 추가됨
    
    - **자동으로 생성되는 기본 생성자의 접근 제한은 클래스의 접근 제한과 동일!!!**
  
  - `**public 접근 제한**`
    
    - 모든 패키지에서 아무런 제한 없이 생성자 호출 가능
  
  - `**protected 접근 제한**`
    
    - default 접근 제한과 마찬가지로 같은 패키지에 속하는 클래스에서 생성자 호출 가능
    - default 접근 제한과 다른 점으로, 다른 패키지에 속한 클래스가 해당 클래스의 자식 클래스라면 생성자 호출 가능
  
  - `**default 접근 제한**`
    
    - 같은 패키지에서는 아무런 제한 없이 생성자 호출 가능
    - 다른 패키지에서는 생성자 호출 불가능
  
  - `**private 접근 제한**`
    
    - 동일한 패키지이건 다른 패키지이건 상관없이 생성자 호출 불가능
    - 오로지 클래스 내부에서만 생성자 호출, 객체 생성 가능

---

- **필드와 메소드의 접근 제한**
  
  - 필드와 메소드 선언 시 해당 필드와 메소드를
    
    1. 클래스 내부에서만 사용할 것인지, 패키지 내에서만 사용할 것인지,
    2. 패키지 내에서만 사용할 것인지,
    3. 다른 패키지에서도 사용할 수 있도록 할 것인지
    
    결정해야 함
  
  - public, protected, default, private 접근 제한 가능

```java
// 필드 선언
[ public | protected | private ] [ static ] 타입 필드;

// 메소드 선언
[ public | protected | private ] [ static ] 리턴타입 메소드(...) { ... }
```

- `**public 접근 제한**`
  - 모든 패키지에서 아무런 제한 없이 필드와 메소드 사용 가능
- `**protected 접근 제한**`
  - default 접근 제한과 마찬가지로 같은 패키지에 속하는 클래스에서 필드와 메소드 사용 가능
  - 차이점으로, 다른 패키지에 속한 클래스가 해당 클래스의 자식 클래스라면 필드와 메소드 사용 가능
- `**default 접근 제한**`
  - 필드와 메소드 선언 시 접근 제한자 생략한다면 default 접근 제한을 가짐
  - 같은 패키지에서는 아무런 제한 없이 필드와 메소드 사용 가능
  - 다른 패키지에서는 필드와 메소드 사용 불가능
- `**private 접근 제한**`
  - 동일한 패키지이건 다른 패키지이건 상관없이 필드와 메소드 사용 불가능
  - 오로지 클래스 내부에서만 사용 가능

---

- 
